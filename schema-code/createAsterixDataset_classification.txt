==== create new dataset with flattened category levels ====

USE TinySocial;

DROP DATASET classification IF EXISTS;
DROP TYPE classificationType IF EXISTS;

CREATE TYPE classificationType AS CLOSED {
	id: UUID,
	nodeID: int,
	classification: string,
	level0: string,
	level1: string,
	level2: string,
	level3: string,
	level4: string,
	level5: string
};

CREATE DATASET classification(classificationType) PRIMARY KEY id autogenerated;

INSERT INTO classification
(SELECT c.nodeID, c.classification, 
c.category.level_0 AS level0,
c.category.nested.level_1 AS level1,
c.category.nested.nested.level_2 AS level2,
c.category.nested.nested.nested.level_3 AS level3,
c.category.nested.nested.nested.nested.level_4 AS level4,
c.category.nested.nested.nested.nested.nested.level_5 AS level5
FROM ClassificationInfo c);


==== query data from new classification dataset ====

USE TinySocial;

SELECT VALUE c
FROM classification c
ORDER BY c.nodeID;


==== function to find specified category at any nesting level ====

USE TinySocial;

DECLARE FUNCTION findCategory(category) {
	(SELECT DISTINCT c.nodeID, c.classification
	FROM classification c
	WHERE c.level0 = category
	OR c.level1 = category
	OR c.level2 = category
	OR c.level3 = category
	OR c.level4 = category
	OR c.level5 = category
	ORDER BY c.nodeID)
};

SELECT VALUE findCategory("Education");
